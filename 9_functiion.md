#9장 함수
함수는 한번정의하면 몇번이고 실행 할 수 있는 코드블록입니다.  
자바스크립트 함수는 매개변수를 가지고 있다.   
(문에서는 전달인자라고 하며, 함수 안으로 들어왔을 때는 매개변수 또는 파라미터라고 부름)  
어떤 객체의 프로퍼티로 할당된 함수를 해당객체의 매서드라고 한다.  
객체를 대상으로 해서 호출하면 이 객체는 해당 함수의 호출 컨텍스트(this)값이 된다.  
중첩된 함수는 해당함수가 정의된 유효범위 안에서 어떤 변수에도 접근할 수 있다. (클로저)  
#함수 정의하기
함수 - 함수 이름 식별자 - 매개변수 -  중괄호(실행되는 본문)
<pre>
function name (e) { 실행되는 머시기 와 return 같은 종료하고 반환되는 머시기(없음 undefined) };   
</pre>
함수 이름에 대한 부분은 본문내용을 참조한다.
함수선언문이 실제로 하는 일 : 어떤 변수를 정의하고 함수 객체를 그 변수에 할당하는 것이다.  
함수 대부분은 return을 포함하고 있으며, 다음에 오는 표현식의 값을 호출자에게 반환한다.
리턴값이 없는 함수를 프로시저(procedure)라고 부르기도 한다.
#중첩함수
다음 예제처럼 함수 중첩가능
<pre>
function hypotenuse(a,b) {
  function square(x) { return X*X;}
  return Math.sqrt(square(a) + square(b));
}
</pre>
중첩된 함수는 해당 함수가 속한 함수 (혹은 함수 들)의 매개변수와 변수에 접근할 수 있다.
#함수 호출하기
+ 일반적인 함수 형태
+ 매서드 형태
+ 생성자
+ call() / apply()  매서드  
일반적인 함수 호출에서 표현식의 값은 그 함수의 반환 값이다. 만약 인터프리터가 return 문을 만나지 못해 함수 끝에 다다르면  
그 반환값은 undefined  

<strong>매서드 호출</strong>
o.m = f;
o.m ();
o.m(x,y);
o['m'](x,y);
a[0](z)

복잡한 프로퍼티 접근 표현식을 포함 할 수 있다.
f().m()
customer.surrname.toUpperCase()

+ 매서드 체이닝
매서드가 객체를 반환하면 매서드의 반환 값을 후속 호출의 일부로 사용
<pre>
// 모든 hadder를 갖고
// 헤더의 id 에 대한 map 함수 결과를 배열로 얻고 get() 정렬 sort() 한다.
$(':hadder').map(function(){return this.id}).get().sort();
</pre>

+ this는 키워드이고 변수나 프로퍼티 이름이 아니기 때문에 this에 값을 할당 할 수 없다.
+ 변수와 달리 this키워드는 유효범위가 없고 중첩 함수는 호출자의 this값을 상속하지 않는다.
+ 만약 중첩 함수가 매서드 형태로 호출되면, 그 함수의 this 값은 그 함수의 호출 대상 객체다.

# 생성자 호출
함수나 매서도 호출 앞에 new키워드가 있다면 생성자 호출
생성자 호출에서 괄호 안에 전달인자 목록이 포함되어 있다면, 우선 전달인자 표현식이 평가되고 함수와
메서드 호출에 경우와 마찬가지로 평가된 전달인자가 함수에 전달된다.

+ 생성자 함수는 객체를 초기화하고, 새로 생성된 이 객체는 생성자 함수의 컨텍스트로 사용된다.
+ 생성자 함수는 this 키워드로 접근 할 수 있다.
+ 생성자 함수는 보통 return 키워드를 사용하지 않는다.

# 간접호출 (뒤에 나오기 때문에 생략)

# 함수 전달인자와 매개변수
자바스크립트에서 함수를 정의할 때는 함수 매개변수의 타입, 즉 자료형을 명시하지 않는다.

+ 생략 가능한 매개변수
본래 정의된 값보다 적은 수의 잔달인자로 함수가 호출되면 나머지 매개변수는  undefined 값으로 설정된다.

# 가변길이 전달인자 목록 : Argument객체
함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수이름이 붙지 않은 인자값을 직접적으로 참조할 방법이 없다.
Argument객체는 이것을 해결해 준다.인덱스 숫자를 통해 함수의 전달 인자를 얻어 올 수 있다.
<pre>
function max (/*...*/){
  var max = Number.NEGATIVE_INFINITY;
  //전달인자를 순회하며 가장 큰 값을 찾아 기억한다.
  for (var i =0 ;i<argment.length;i++)
  if (argment[i] > max) max = argment[i];
  //가장 큰 값을 반환한다.
  return max;
}
var largest = max(1,10,100,2,3,1000,4,5,10000,6); // => 10000
</pre>
