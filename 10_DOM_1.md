##### 이 글은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍 요약입니다.
##### 공부하기위한 비공식 문서로 블로그에 기재하지 않습니다.
<hr>
이 장에서 다루는 내용  
+ DOM을 노드의 계층 구조로 이해  
+ 다양한 노드 타입
+ 브라우저들 간의 비호환성을 우회하는 DOM코딩  

문서객체모델(DOM)은 HTML과 XML문서에 대한 애플리케이션 프로그래밍 인터페이스(API) 이다. DOM은 문서를 노드의 계층 트리로 표현하며 개발자는 이를 통해 페이지 각 부분을 추가,제거,수정 한다.   

Node 타입  
DOM Lv1 에서는 Node라는 인터페이스가 있는데 DOM에 존재하는 노드 타입은 모두 이 인터페이스를 구현한다. node인터페이스는 자바스크립트에서 Node타입으로 구현되며 자바스크립트의 노드타입은 모두 Node를 상속하므로 모든 노드타입에서 기본 프로퍼티와 매서드를 공유한다. 노드 타입은 다음 12가지 숫자형 상수 중하나이다. 이 상수는 Node타입에 정의되어 있다.  
<pre>
Node.ELEMENT_NODE(1)
Node.ATTRIBUTE_NODE(2)
Node.TEXT_NODE(3)
Node.CDATA_SECTION_NODE(4)
Node.ENTITY_REFERENCE_NODE(5)
Node.ENTITY_NODE(6)
Node.PROCESSING_INSTRUCTION_NODE(7)
Node.COMMENT_NODE(8)
Node.DOCUMENT_NODE(9)
Node.DOCUMENT_TYPE_NODE(10)
Node.DOCUMENT_FRAGMENT_NODE(11)
Node.NOTATION_NODE(12)
</pre>
노드 타입을 알아보려면 다음과 같이 이 상수와 비교해 보면 된다.  
<pre>
if (someNode.nodeType == Node.ELEMENT_NODE){
  alert("Node is an element");
}
</pre>
이 예제에서는 someNode.nodeType과 Node.ELEMENT_NODE상수를 비교했다. 둘이 같다면 someNode는 요소 노드이다. 브라우저 호환성을 위해 다음과 같ㅇ nodeType프로퍼티를 숫자형 값과 비교하는것이 좋다.  
<pre>
if (someNode.nodeType == 1){
  //모든 브라우저에서 동작
  alert("Node is an element");
}
</pre>
웹 브라우저에서 모든 노드타입을 지원하지는 않지만, 각 노드타입에 대한 지원 레벨과 사용법은 뒤에서 다시 설명한다.  

nodeName,nodeValue 프로퍼티  
nodeName과 nodeValue프로퍼티는 해당 노드의 정보를 제공한다. 프로퍼티 값은 노드 타입에 따라 완전히 다르다. 이 값을 사용하기 전에 항상 다음 코드처럼 노트타입을 테스트 하길 권한다.  
<pre>
if (someNode.nondeType == 1){
  value = someNode.nodeName; // 요소의 테그 이름
}
</pre>
이 예제에서는 노드타입을 체크해서 노드가 요소임을 확인했다. 노드가 요소라면 nodeName값을 변수에 할당한다. 요소의 nodeName은 항상 요소의 테그 이름과 일치하며 nodeValue는 항상 null이다.  

노드 사이의 관계  
모든 노드는 다른 노드와 관계가 있다 이런관계는 문서 트리를 가족계보처럼 생각해서 가족관계로 설며하곤 한다. HTML에서 <body>는 <HTML>요소의 자식이며 <head>요소는 <body>와 형제 요소로 간주한다. 각 노드에는 childNode프로퍼티가 있는데 이 프로퍼티에는 NodeList가 자정된다. NodeList는 배열 비슷한 객체인데, 노드를 순서있는 목록으로 저장하여 위치 기반으로 접근 할 수 있다. NodeList에 length프로퍼티가 있고 저장된데이터를 대괄호 표기법으로 접근 할 수 있긴 하지만 Array는 아니다. NodeList객체는 사실 DOM구조에 대한 쿼리 결과이며 문서가 바뀌면 NodeList객체도 자동으로 반영된다는 점을 기억해야 한다. NodeList는 처음 호출했을 때 얻은 결과물을 저장하고 있는것이 아니라 계속 바뀌므로 살아있는 객체라고 부르기도 한다. 다음 예제는 대괄호 표기법으로 접근하는 법이다.   
<pre>
var firstChild = someNode.childNode[0];
var secondChild = someNode.childNode.item(1);
var count = someNode.childNode.length;
</pre>
length프로퍼티는 '호출당시' NodeList에 담긴 노드 숫자임을 기억해야 하고  argument 객체에서 설명했던 데로 Array.prototype.slice()를 사용해 NodeList객체를 배열로 변경 할 수 있다 다음예제를 확인해 보자.  
<pre>
var arrayOfNode = Array.prototype.slice.call(some.childNodes,0);
</pre>
위의 방법은 IE8에는 동작안하지만, 다음 함수는 모든 브라우저에서 동작한다.  
<pre>
function convertToArray(nodes){
  var array = null;
  try{
    array = Array.prototype.slice.call(nodes,0); // IE9+
  } catch(ex){
    array = new Array();
    for(var i = 0, len=nodes.length; i <len; i++){
      array.push(nodes[i]);
    }
  }
  return array;
}
</pre>
convertToArray()함수는 배열을 생성하는 쉬운 방법부터 시도한다. 에러가 생기면 try-catch 블록에서 에러를 받아 배열을 직접 생성한다. 이 함수도 쿽스 탐지의 한 가지 형태이다. 각 노드에는 문서 트리에서 부모를 가리키는 parentNode프로퍼티가 있다. childNodes목록에 포함된 노드는 모두 부모가 같으므로 각각의 parentNode프로퍼티는 같은 노드를 가리킨다. 또한 childNodes목록의 각 노드는 형제관계이다. 같은 목록에 있는 노드 사이를 previousSilbling및 nextSilbling프로퍼티로 이동 할 수 있다 다음 예제와 같이 목록의 첫 번째 노드에서 previousSilbling프로퍼티 값은 null이며 마지막 노드에서 nextSilbling프로퍼티 값은 null이다.  </pre>

<pre>
if (someNode.nextSilbling === null){
  alert("Last node in the parent's childNodes list");
}else if(someNode.previousSilbling === null){
  alert("First node in the parent's childNodes list");
}
</pre>

자식 노드가 하나 뿐이라면 해당 노드의 nextSilbling와 previousSilbling은 모두 null 이다. 부모 노드의 첫 번째, 마지막 자식 노드 관계를 가리키는 다른 관계도 존재한다. 아래의 그림을 보면 보다 더 쉽게 알 수 있다.  </pre>

![Minion](https://github.com/jinyounghwa/i-dont-nothing-javascript/blob/master/image/dom1.png)

노드의 조작  
노드 사이의 관계 포인터는 모두 읽기 전용이므로 노드를 조작하는 매서드는 따로 있다. 가장 자주 쓰이는 매서드는 appendChild()인데 이 매서드는 childNodes목록에 노드를 추가한다. 이 매서드를 실행하면 새로 추가한 노드, 부모 노드, childNodes목록에 포함된 이전의 마지막 노드에서 모든 관계포인터가 업데이트 된다. 업데이트가 완료되면 appendChild()는 새로 추가한 노드가 반환한다. 다음 예제를 확인하자.  
<pre>
var returnedNode = someNode.appendChild(newNode);
alert(returnedNode == newNode); // true
alert(someNode.lastChild == newNode); //true
</pre>
appendChild()에 넘긴 노드가 이미 문서에 존재하고 있었다면 해당 노드는 이전의 위치를 벗어나 새 위치로 이동한다. DOM트리가 수많은 포인터로 연결되어 있긴 하지만 문서에서 두 위치에 동시에 존재할 수 있는 DOM노드는 없다. 따라서 다음 예제처럼 appendChild()를 호출하면서 첫 번째 자식을 넘기면 해당 요소는 결국 마지막 자식이 된다.  
<pre>
//someNode의 여러 자식 노드에 접근
var returnedNode = someNode.appendChild(someNode.firstChild);
alert(returnedNode == someNode.firstChild); //false
alert(returnedNode == someNode.lastChild); //true
</pre>
한 노드를 childNodes목록 마지막이 아니라 특정 위치로 옮겨야 할 때는 insertBefore()매서드를 사용한다 insertBefore()매서드는 삽입할 노드와 기준 노드 두 가지를 매개변수로 받는다. 삽입한 노드는 기준 노드의 이전 형제가 되며 이동이 끝나면 매서드는 삽입한 노드를 반환한다. 기준 노드가 null이라면 insertBefore()는 다음 예제처럼 appendChild()와 똑같이 동작한다.  
<pre>
//마지막 자식으로 삽입
returnedNode = someNode.insertBefore(newNode, null);
alert(newNode == someNode.lastChild); //true
//첫 자식으로 삽입
returnedNode = someNode.insertBefore(newNode, someNode.firstChild);
alert(returnedNode == newNode);//true
alert(newNode == someNode.firstChild)l //true
//마지막 자식 앞에 삽입
returnedNode = someNode.insertBefore(newNode, someNode.lastChild);
alert(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true
</pre>
appendChild()와 insertBefore()는 모두 기존의 노드를 제거하는 일 없이 삽입으로만 작동한다. 반면 replaceChiild()매서드는 기존 노드를 교체한다. replaceChiild()매서드는 매개변수로 삽입할 노드(A)와 교체할 노드(B)두 개를 받아서 B를 문서 트리에서 제거해 반환하며 B가 있던 자리에 A를 대신 삽입한다. 다음 예제를 확인하자.  
<pre>
//첫번째 자식을 교체
var returnedNode = someNode.replaceChiild(newNode, someNode.firstChild);

//마지막 자식을 교체
returnedNode = someNode.replaceChiild(newNode, someNode.lastChild);
</pre>
replaceChiild()로 노드를 삽입하면 B의 관계포인터를 모두 A에 복사한다. B는 아직 같은 문서 소유이긴 하지만 문서 위치를 지정받지는 못핸 채 붕 떠 있는 상태이다. 노드를 제거 할 때는 removeChild()매서드를 사용한다. 이 매서드는 제거할 노드 하나만 매개변수로 받는다. 제거된 노드는 다음 예제처럼 함수 값으로 반환된다.  
<pre>
//첫번째 자식을 제거
var formerFirstChild = someNode.removeChild(someNode.firstChild);

//마지막 자식을 제거
var formerFirstChild = someNode.removeChild(some.lastChild);
</pre>
replaceChiild()와 마찬가지로 removeChild()로 제거한 노드 역시 아직 해당문서 소유이긴 하지만 문서에서 위치를 지정받지는 못했다. 이들 네 가지 매서드는 모두 특정 노드의 자식에서만 동작하므로 parentNode프로퍼티에 해당하는 부모 노드를 정확히 알아야 한다. 자식을 가질 수 없는 노드 타입도 있으며 이런 노드에서 이들 매서드를 호출하면 에러가 발생한다.  

기타 매서드  
다른 두 매서드는 모든 노드 타입에서 공통이다. cloneNode()매서드는 자신을 호출한 노드의 복제본을 생성한다. cloneNode()매서드는 매개변수를 하나 받는데 이는 자손 노드까지 복제할 지 나타내는 불리언이다. 매개변수로 true를 넘기면 자손노드 전체를 복제하며 false를 넘기면 노드 하나만 복제한다. 복제된 노드를 반환하는데 이는 여전히 문서 소유지만 부모 노드가 할당되지 않았다. 따라서 복제된 노드는 고아 노드이며 appendChild()나 insertBefore(), replaceChiild()를 통해 문서에 추가하지 전에는 트리안에 존재하지 않는다. 아래의 예제를 보자.  
<pre>
< ul >
  < li >item 1< /li >
  < li >item 2< /li >
  < li >item 3< /li >
< /ul >
</pre>
이 <ul> 요소에 대한 참조를 변수 myList에 저장했다고 가정하면 다음 코드처럼
