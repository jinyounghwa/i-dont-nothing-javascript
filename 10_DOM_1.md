##### 이 글은 프론트엔드 개발자를 위한 자바스크립트 프로그래밍 요약입니다.
##### 공부하기위한 비공식 문서로 블로그에 기재하지 않습니다.
<hr>
이 장에서 다루는 내용  
+ DOM을 노드의 계층 구조로 이해  
+ 다양한 노드 타입
+ 브라우저들 간의 비호환성을 우회하는 DOM코딩  

문서객체모델(DOM)은 HTML과 XML문서에 대한 애플리케이션 프로그래밍 인터페이스(API) 이다. DOM은 문서를 노드의 계층 트리로 표현하며 개발자는 이를 통해 페이지 각 부분을 추가,제거,수정 한다.   

Node 타입  
DOM Lv1 에서는 Node라는 인터페이스가 있는데 DOM에 존재하는 노드 타입은 모두 이 인터페이스를 구현한다. node인터페이스는 자바스크립트에서 Node타입으로 구현되며 자바스크립트의 노드타입은 모두 Node를 상속하므로 모든 노드타입에서 기본 프로퍼티와 매서드를 공유한다. 노드 타입은 다음 12가지 숫자형 상수 중하나이다. 이 상수는 Node타입에 정의되어 있다.  
<pre>
Node.ELEMENT_NODE(1)
Node.ATTRIBUTE_NODE(2)
Node.TEXT_NODE(3)
Node.CDATA_SECTION_NODE(4)
Node.ENTITY_REFERENCE_NODE(5)
Node.ENTITY_NODE(6)
Node.PROCESSING_INSTRUCTION_NODE(7)
Node.COMMENT_NODE(8)
Node.DOCUMENT_NODE(9)
Node.DOCUMENT_TYPE_NODE(10)
Node.DOCUMENT_FRAGMENT_NODE(11)
Node.NOTATION_NODE(12)
</pre>
노드 타입을 알아보려면 다음과 같이 이 상수와 비교해 보면 된다.  
<pre>
if (someNode.nodeType == Node.ELEMENT_NODE){
  alert("Node is an element");
}
</pre>
이 예제에서는 someNode.nodeType과 Node.ELEMENT_NODE상수를 비교했다. 둘이 같다면 someNode는 요소 노드이다. 브라우저 호환성을 위해 다음과 같ㅇ nodeType프로퍼티를 숫자형 값과 비교하는것이 좋다.  
<pre>
if (someNode.nodeType == 1){
  //모든 브라우저에서 동작
  alert("Node is an element");
}
</pre>
웹 브라우저에서 모든 노드타입을 지원하지는 않지만, 각 노드타입에 대한 지원 레벨과 사용법은 뒤에서 다시 설명한다.  

nodeName,nodeValue 프로퍼티  
nodeName과 nodeValue프로퍼티는 해당 노드의 정보를 제공한다. 프로퍼티 값은 노드 타입에 따라 완전히 다르다. 이 값을 사용하기 전에 항상 다음 코드처럼 노트타입을 테스트 하길 권한다.  
<pre>
if (someNode.nondeType == 1){
  value = someNode.nodeName; // 요소의 테그 이름
}
</pre>
이 예제에서는 노드타입을 체크해서 노드가 요소임을 확인했다. 노드가 요소라면 nodeName값을 변수에 할당한다. 요소의 nodeName은 항상 요소의 테그 이름과 일치하며 nodeValue는 항상 null이다.  

노드 사이의 관계  
모든 노드는 다른 노드와 관계가 있다 이런관계는 문서 트리를 가족계보처럼 생각해서 가족관계로 설며하곤 한다. HTML에서 <body>는 <HTML>요소의 자식이며 <head>요소는 <body>와 형제 요소로 간주한다. 각 노드에는 childNode프로퍼티가 있는데 이 프로퍼티에는 NodeList가 자정된다. NodeList는 배열 비슷한 객체인데, 노드를 순서있는 목록으로 저장하여 위치 기반으로 접근 할 수 있다. NodeList에 length프로퍼티가 있고 저장된데이터를 대괄호 표기법으로 접근 할 수 있긴 하지만 Array는 아니다. NodeList객체는 사실 DOM구조에 대한 쿼리 결과이며 문서가 바뀌면 NodeList객체도 자동으로 반영된다는 점을 기억해야 한다. NodeList는 처음 호출했을 때 얻은 결과물을 저장하고 있는것이 아니라 계속 바뀌므로 살아있는 객체라고 부르기도 한다. 다음 예제는 대괄호 표기법으로 접근하는 법이다.   
<pre>
var firstChild = someNode.childNode[0];
var secondChild = someNode.childNode.item(1);
var count = someNode.childNode.length;
</pre>
length프로퍼티는 '호출당시' NodeList에 담긴 노드 숫자임을 기억해야 하고  argument 객체에서 설명했던 데로 Array.prototype.slice()를 사용해 NodeList객체를 배열로 변경 할 수 있다 다음예제를 확인해 보자.  
<pre>
var arrayOfNode = Array.prototype.slice.call(some.childNodes,0);
</pre>
위의 방법은 IE8에는 동작안하지만, 다음 함수는 모든 브라우저에서 동작한다.  
<pre>
function convertToArray(nodes){
  var array = null;
  try{
    array = Array.prototype.slice.call(nodes,0); // IE9+
  } catch(ex){
    array = new Array();
    for(var i = 0, len=nodes.length; i <len; i++){
      array.push(nodes[i]);
    }
  }
  return array;
}
</pre>
convertToArray()함수는 배열을 생성하는 쉬운 방법부터 시도한다. 에러가 생기면 try-catch 블록에서 에러를 받아 배열을 직접 생성한다. 이 함수도 쿽스 탐지의 한 가지 형태이다. 각 노드에는 문서 트리에서 부모를 가리키는 parentNode프로퍼티가 있다. childNodes목록에 포함된 노드는 모두 부모가 같으므로 각각의 parentNode프로퍼티는 같은 노드를 가리킨다. 또한 childNodes목록의 각 노드는 형제관계이다. 같은 목록에 있는 노드 사이를 previousSilbling및 nextSilbling프로퍼티로 이동 할 수 있다 다음 예제와 같이 목록의 첫 번째 노드에서 previousSilbling프로퍼티 값은 null이며 마지막 노드에서 nextSilbling프로퍼티 값은 null이다.  
<pre>
if (someNode.nextSilbling === null){
  alert("Last node in the parent's childNodes list");
}else if(someNode.previousSilbling === null){
  alert("First node in the parent's childNodes list");
}
</pre>
자식 노드가 하나 뿐이라면 해당 노드의 nextSilbling와 previousSilbling은 모두 null 이다. 부모 노드의 첫 번째, 마지막 자식 노드 관계를 가리키는 다른 관계도 존재한다. 아래의 그림을 보면 보다 더 쉽게 알 수 있다. (사실 학원에서 이것만 죽어라 배운것 같은 느낌적인 느낌이 든다.)
 
![Minion](https://github.com/jinyounghwa/i-dont-nothing-javascript/blob/master/image/dom_1.png)
